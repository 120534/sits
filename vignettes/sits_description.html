<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Introduction</h1>

<p>Earth observation satellites provide a continuous and consistent set of information about the Earth’s land and oceans. Most space agencies have adopted an open data policy, making unprecedented amounts of satellite data available for research and operational use. This data deluge has brought about a major challenge: \textit{How to design and build technologies that allow the Earth observation community to analyse big data sets?}</p>

<p>The approach taken in the current package is to develop data analysis methods that work with satellite image time series (SITS). The time series are obtained by taking calibrated and comparable measures of the same location in Earth at different times. These measures can be obtained by a single sensor (e.g., MODIS) or by combining different sensores (e.g., LANDSAT-8 and SENTINEL-2). If obtained by frequent revisits, the temporal resolution of these data sets can capture the most important land use changes. </p>

<p>Time series of remote sensing data show that land cover changes do not always occur in a progressive and gradual way, but they may also show periods of rapid and abrupt change followed either by a quick recovery [@Lambin2003]. Analyses of multiyear time series of land surface attributes, their fine-scale spatial pattern, and their seasonal evolution leads to a broader view of land-cover change. Satellite image time series have already been applied to applications such as mapping for detecting forest disturbance [@Kennedy2010], ecology dynamics [@Pasquarella2016], agricultural intensification [@Galford2008] and its impacts on deforestation [@Arvor2012].</p>

<p>The SITS package provides support on how to use statistical learning techniques with image time series. In a broad sense, statistical learning refers to a class of algorithms for classification and regression analysis [@Hastie2009]. These methods include linear and quadratic discrimination analysis, support vector machines, random forests and neural networks. In a typical classification problem, we have measures that capture class attributes. Based on these measures, referred as training data, one&#39;s task is to select a predictive model that allows inferring classes of a larger data set. </p>

<p>Current approaches to image time series analysis still use limited number of attributes. A common approach is deriving a small set of phenological parameters from vegetation indexes, like beginning, peak, and length of growing season [@Brown2013] [@Kastens2017] [@Estel2015] [@Pelletier2016]. These phenological parameters are then fed in specialised classifiers such as TIMESAT [@Jonsson2004]. These approaches do not use the power of advanced statistical learning techniques to work on high-dimensional spaces and with big training data sets [@James2013].</p>

<p>The SITS package uses the full depth of satellite image time series to create larger dimensional spaces. We tested different methods of extracting attributes from time series data, including those reported by @Pelletier2016 and @Kastens2017. Our conclusion is that part of the information in raw time series is lost after filtering or statistical approximation. Thus, the method we developed has a deceptive simplicity: \emph{use all the data available in the time series samples}. The idea is to have as many temporal attributes as possible, increasing the dimension of the classification space. Our experiments found out that modern statistical models such as support vector machines, and random forests perform better in high-dimensional spaces than in lower dimensional ones. </p>

<p>In what follows, we describe the main characteristics of the SITS package. The first part  describes the basic data structures used in SITS and the tools used for visualisation and data exploration. Then we show how to do data acquision from external sources, with an emphasis on the WTSS (&ldquo;web time series service&rdquo;). The next sections describe filtering and clustering techniques. We then discuss machine learning techiques for SITS data and how to apply them to image time series. Finally, we present validation methods.</p>

<h1>Data Handling and Visualisation Basics in SITS</h1>

<p>The basic data unit in the sits package is the SITS tibble, which is a way of organizing a set of time series data with associated spatial information. In R, a &ldquo;tibble&rdquo; differs from the traditional data frame, insofar as a tibble can contain lists embedded as column arguments. Tibbles are part of the &ldquo;tidyverse&rdquo;, a collection of R package designed to work together in data manipulation. The &ldquo;tidyverse&rdquo; includes packages such as &ldquo;ggplot2&rdquo;, &ldquo;dplyr&rdquo; and &ldquo;purrr&rdquo; [@Wickham2017]. The &ldquo;SITS&rdquo; package makes extensive use of the &ldquo;tidyverse&rdquo;. </p>

<p>For a better explanation of how the &ldquo;SITS tibble&rdquo; works, we will read a data set containing  2,115 labelled samples of land cover in Mato Grosso state of Brazil. This state has 903,357 km\textsuperscript{2} of extension, being the third largest state of Brazil. It includes three of Brazil&#39;s biomes: Amazonia, Cerrado and Pantanal. It is the most important agricultural frontier of Brazil and is Brazil&#39;s largest producer of soybeans, corn and cotton. </p>

<p>The samples contain time series extracted from the MODIS MOD13Q1 product from NASA from 2001 to 2016, provided every 16 days at 250-meter spatial resolution in the Sinusoidal projection. Based on ground surveys and high resolution imagery, we selected 2,115 samples of nine classes: forest, cerrado, pasture, soybean-fallow, fallow-cotton,  soybean-cotton, soybean-corn, (8) soybean-millet, soybean-sunflower. Crop and pasture ground data was collected by researchers Alexandre Coutinho, Julio Esquerdo and Joao Antunes from the Brazilian Agricultural Research Agency (EMBRAPA) through farmer interviews in October 2009 and in October 2013. Samples for cerrado and forest classes were provided by Rodrigo Bergotti from INPE. Ground samples for soybean-fallow class were provided by Damien Arvor[@Arvor2012].</p>

<pre><code class="r"># retrieve a set of samples from an RDS file
samples.tb &lt;- readRDS(system.file(&quot;extdata/time_series/embrapa_mt.rds&quot;, 
                                     package = &quot;sits&quot;))
samples.tb
</code></pre>

<pre><code>## # A tibble: 2,115 x 7
##    longitude latitude start_date   end_date   label    coverage
##        &lt;dbl&gt;    &lt;dbl&gt;     &lt;date&gt;     &lt;date&gt;   &lt;chr&gt;       &lt;chr&gt;
##  1  -55.1852 -10.8378 2013-09-14 2014-08-29 Pasture mod13q1_512
##  2  -57.7940  -9.7573 2006-09-14 2007-08-29 Pasture mod13q1_512
##  3  -51.9412 -13.4198 2014-09-14 2015-08-29 Pasture mod13q1_512
##  4  -55.9643 -10.0621 2005-09-14 2006-08-29 Pasture mod13q1_512
##  5  -54.5540 -10.3749 2013-09-14 2014-08-29 Pasture mod13q1_512
##  6  -52.4572 -10.9512 2013-09-14 2014-08-29 Pasture mod13q1_512
##  7  -52.1443 -13.9981 2013-09-14 2014-08-29 Pasture mod13q1_512
##  8  -57.6907 -13.3382 2015-09-14 2016-08-28 Pasture mod13q1_512
##  9  -54.7034 -16.4265 2015-09-14 2016-08-28 Pasture mod13q1_512
## 10  -53.6543 -15.7155 2014-09-14 2015-08-29 Pasture mod13q1_512
## # ... with 2,105 more rows, and 1 more variables: time_series &lt;list&gt;
</code></pre>

<p>The &ldquo;SITS tibble&rdquo; contains data and metadata. The first six columns contain the metadata: spatial and temporal location, label assigned to the sample, and coverage from where the data has been extracted. The spatial location is given in longitude and latitude coordinates for the &ldquo;WGS84&rdquo; ellipsoid. For example, the first sample has been labelled &ldquo;Pasture&rdquo;, at location (-55.1852, -10.8387), and is considered valid for the period (2013-09-14, 2014-08-29). Informing the dates where the label is valid is crucial for correct classification. In this case, the researchers involved in labelling the samples chose to use the agricultural calendar in Brazil, where the spring crop is planted in the months of September and October, and the autmun crop is planted in the months of February and March. For other applications and other countries, the relevant dates will most likely be different from those used in the example.</p>

<p>The SITS tibble also contains the time series data for each spatiotemporal location. The timeseries data is also organized as a tibble, with a column with the dates and the other columns with the values for each spectral band. </p>

<pre><code class="r">#print the first time series
samples.tb[1,]$time_series
</code></pre>

<pre><code>## [[1]]
## # A tibble: 23 x 7
##         Index   ndvi    evi    nir    mir   blue    red
##  *     &lt;date&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
##  1 2013-09-14 0.4245 0.2800 0.2879 0.2439 0.0605 0.1163
##  2 2013-09-30 0.4673 0.2642 0.2570 0.1672 0.0357 0.0933
##  3 2013-10-16 0.5039 0.2993 0.2659 0.2019 0.0405 0.0877
##  4 2013-11-01 0.6489 0.4071 0.2762 0.1026 0.0266 0.0588
##  5 2013-11-17 0.7956 0.6692 0.4552 0.0875 0.0271 0.0518
##  6 2013-12-03 0.7248 0.5400 0.3661 0.0799 0.0516 0.0584
##  7 2013-12-19 0.7971 0.5574 0.3490 0.0478 0.0171 0.0394
##  8 2014-01-01 0.8049 0.7228 0.5255 0.1030 0.0327 0.0568
##  9 2014-01-17 0.7364 0.6867 0.5165 0.1449 0.0629 0.0784
## 10 2014-02-02 0.7870 0.7342 0.5320 0.1323 0.0452 0.0634
## # ... with 13 more rows
</code></pre>

<p>The SITS package provides functions for data manipulation and displaying information of a SITS tibble. For example, the function is <code>sits_bands</code> that lists the available bands.</p>

<pre><code class="r">sits_bands (samples.tb)
</code></pre>

<pre><code>## [1] &quot;ndvi&quot; &quot;evi&quot;  &quot;nir&quot;  &quot;mir&quot;  &quot;blue&quot; &quot;red&quot;
</code></pre>

<p>Another useful command is <code>sits_labels</code> that shows the labels of the sample set and their frequencies.</p>

<pre><code class="r">sits_labels (samples.tb)
</code></pre>

<pre><code>## # A tibble: 9 x 3
##           label count       freq
##           &lt;chr&gt; &lt;int&gt;      &lt;dbl&gt;
## 1       Cerrado   400 0.18912530
## 2 Fallow_Cotton    34 0.01607565
## 3        Forest   138 0.06524823
## 4       Pasture   370 0.17494090
## 5      Soy_Corn   398 0.18817967
## 6    Soy_Cotton   399 0.18865248
## 7    Soy_Fallow    88 0.04160757
## 8    Soy_Millet   235 0.11111111
## 9 Soy_Sunflower    53 0.02505910
</code></pre>

<p>In many cases, it is useful to relabel the data set. For examples, there may be situations when one wants to use a smaller set of labels, since samples in one label on the original set may not be distinguishable for samples with other labels. We then should use the <code>sits_relabel</code> function. This function requires a conversion list, as shown in the example below.</p>

<pre><code class="r"># a list for relabelling the samples
new_labels &lt;- list(&quot;Cerrado&quot;       = &quot;Savanna&quot;, 
                   &quot;Pasture&quot;       = &quot;Grasslands&quot;, 
                   &quot;Soy_Corn&quot;      = &quot;Double_Cropping&quot;,
                   &quot;Soy_Cotton&quot;    = &quot;Double_Cropping&quot;,
                   &quot;Soy_Sunflower&quot; = &quot;Double_Cropping&quot;,
                   &quot;Soy_Fallow&quot;    = &quot;Single_Cropping&quot;,
                   &quot;Soy_Millet&quot;    = &quot;Single_Cropping&quot;,
                   &quot;Fallow_Cotton&quot; = &quot;Single_Cropping&quot;)
# apply the sits_relabel function
samples2.tb &lt;- sits_relabel(samples.tb, new_labels)
# view the result
sits_labels(samples2.tb)
</code></pre>

<pre><code>## # A tibble: 5 x 3
##             label count       freq
##             &lt;chr&gt; &lt;int&gt;      &lt;dbl&gt;
## 1 Double_Cropping   850 0.40189125
## 2          Forest   138 0.06524823
## 3      Grasslands   370 0.17494090
## 4         Savanna   400 0.18912530
## 5 Single_Cropping   357 0.16879433
</code></pre>

<p>Given that we have used the tibble data format for the metadata and and the embedded time series, one can use the functions of the <code>dplyr</code>, <code>tidyr</code> and <code>purrr</code> packages of the &ldquo;tidyverse&rdquo; [@Wickham2017] to process the data. For example, the following example uses the <code>sits_select</code> function to get a subset of the sample data set with two bands (&ldquo;ndvi&rdquo; and &ldquo;evi&rdquo;) and then uses the <code>dplyr::filter</code> function to select the samples labelled either as &ldquo;Cerrado&rdquo; or &ldquo;Pasture&rdquo;. We can then use the <code>sits_plot</code> function to display the time series. Given a small number of samples to display, the <code>sits_plot</code> function tries to group as many spatial locations together. In the following example, the first 15 samples of the &ldquo;Cerrado&rdquo; class all refer to the same spatial location in consecutive times. For this reason, these samples are plotted together.</p>

<pre><code class="r"># select the &quot;ndvi&quot; bands
samples_ndvi.tb &lt;- sits_select(samples.tb, bands = c(&quot;ndvi&quot;))
# select only the samples with the cerrado label
samples_cerrado.tb &lt;- dplyr::filter (samples_ndvi.tb, label == &quot;Cerrado&quot;)
# plot the first 15 samples (different dates for the same points)
sits_plot (samples_cerrado.tb[1:15,])
</code></pre>

<p>For a large number of samples, where the amount of individual plots would be substantial, the default visualisation combines all samples together in a single temporal interval (even if they are valid for different years). Therefore, all samples of the same band and the same label are aligned to a common interval. This plot is useful to show the spread of values for the time series of each band. The strong red line in the plot shows the median of the values, and the two orange lines are the first and third interquartile ranges. The <code>sits_plot</code> function has different ways of working. Please refer to the documentation for more details.</p>

<pre><code class="r"># plot all cerrado samples together (shows the distribution)
sits_plot (samples_cerrado.tb)
</code></pre>

<h1>Importing data into SITS</h1>

<p>The SITS package allows different methods of data input, including: (a) obtain data from a WTSS (Web Series Time Service); (b) read data stored in a time series in the ZOO format [@Zeileis2005]; &copy; read a time series from a RasterBrick [@Hijmans2015]. This section describes options (a) and (b). Option &copy; will be described in the section were we describe raster processing. The WTSS service is a light-weight service, designed to retrieve time series for selected locations and periods [@Vinhas2016]. This service has been implemented by the research team of the National Institute for Space Research to allow remote access to time series data. To access the service, the user needs to provide a URL that points to the WTSS server location and use the function <code>sits_infoWTSS</code> that provides information on the coverages available on the server.</p>

<pre><code class="r">URL &lt;- &quot;http://www.dpi.inpe.br/tws/wtss&quot;
wtss_inpe &lt;- sits_infoWTSS(URL)
</code></pre>

<p>After finding out which coverages are available at the WTSS service, one may request specific information on each coverage by using the function <code>sits_coverageWTSS</code> which lists the contents of the data set, including source, bands, spatial extent and resolution, time range, and temporal resolution. This information is then stored in a tibble for later use.</p>

<pre><code class="r"># get information about a specific coverage
coverage.tb &lt;- sits_coverageWTSS(URL,&quot;mod13q1_512&quot;)
</code></pre>

<p>The user can then request one or more points using the <code>sits_getdata</code> function. This function provides a general means of access to image time series. In it simplest fashion, the user provides the latitude and longitude of the desired location, the URL of the WTSS services, the coverage name, the bands, and the start date and end date of the time series. If the start and end dates are not provided, all of the samples are retrived. The result is a SITS tibble that can be visualised using <code>sits_plot</code>. </p>

<pre><code class="r"># a point in the transition forest pasture in Northern MT
long &lt;- -55.57320
lat &lt;- -11.50566
# obtain a time series from the WTSS server for this point
series.tb &lt;- sits_getdata(longitude = long, latitude = lat, URL = URL, 
             coverage = &quot;mod13q1_512&quot;, bands = c(&quot;ndvi&quot;, &quot;evi&quot;),
             start_date = &quot;2001-01-01&quot;, end_date = &quot;2016-12-31&quot;)
# plot the series
sits_plot (series.tb)
</code></pre>

<p>A useful case is when users have a set of labelled samples, that are to be used as a training data set. In this case, one usually has some field data or trusted observations which are labelled. </p>

<!--
# References
\setlength{\parindent}{-0.2in}
\setlength{\leftskip}{0.2in}
\setlength{\parskip}{8pt}
\vspace*{-0.2in}
\noindent
-->

</body>

</html>
